import "./chunk-CEQRFMJQ.js";

// node_modules/scroll-snap/dist/esm/index.js
function easeInOutQuad(t) {
  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}
var TIMEOUT_MIN = 50;
var TIMEOUT_DEFAULT = 100;
var DURATION_DEFAULT = 300;
var THRESHOLD_DEFAULT = 0.2;
var SNAPSTOP_DEFAULT = false;
var EASING_DEFAULT = easeInOutQuad;
var NOOP = function() {
};
function createScrollSnap(element, settings, callback) {
  if (settings === void 0) {
    settings = {};
  }
  var onAnimationEnd = typeof callback === "function" ? callback : NOOP;
  var listenerElement;
  var target;
  var animating = false;
  var scrollHandlerTimer;
  var scrollSpeedTimer;
  var scrollStart;
  var speedDeltaX;
  var speedDeltaY;
  var snapLengthUnit;
  var lastScrollValue = {
    x: 0,
    y: 0
  };
  var animationFrame;
  var snapDestinationX = settings.snapDestinationX, snapDestinationY = settings.snapDestinationY;
  if (snapDestinationX && typeof snapDestinationX !== "string" && typeof snapDestinationX !== "number") {
    throw new Error("Settings property 'snapDestinationX' is not valid, expected STRING or NUMBER but found " + (typeof snapDestinationX).toUpperCase());
  }
  if (snapDestinationY && typeof snapDestinationY !== "string" && typeof snapDestinationY !== "number") {
    throw new Error("Settings property 'snapDestinationY' is not valid, expected STRING or NUMBER but found " + (typeof snapDestinationY).toUpperCase());
  }
  if (settings.timeout && (isNaN(settings.timeout) || typeof settings.timeout === "boolean")) {
    throw new Error("Optional settings property 'timeout' is not valid, expected NUMBER but found " + (typeof settings.timeout).toUpperCase());
  }
  var timeout = settings.timeout && settings.timeout >= TIMEOUT_MIN ? settings.timeout : TIMEOUT_DEFAULT;
  if (settings.duration && (isNaN(settings.duration) || typeof settings.duration === "boolean")) {
    throw new Error("Optional settings property 'duration' is not valid, expected NUMBER but found " + (typeof settings.duration).toUpperCase());
  }
  var duration = settings.duration || DURATION_DEFAULT;
  if (settings.threshold && (isNaN(settings.threshold) || typeof settings.threshold === "boolean")) {
    throw new Error("Optional settings property 'threshold' is not valid, expected NUMBER but found " + (typeof settings.threshold).toUpperCase());
  }
  var threshold = settings.threshold || THRESHOLD_DEFAULT;
  if (settings.easing && typeof settings.easing !== "function") {
    throw new Error("Optional settings property 'easing' is not valid, expected FUNCTION but found " + (typeof settings.easing).toUpperCase());
  }
  var easing = settings.easing || EASING_DEFAULT;
  if (settings.snapStop && typeof settings.snapStop !== "boolean") {
    throw new Error("Optional settings property 'snapStop' is not valid, expected BOOLEAN but found " + (typeof settings.snapStop).toUpperCase());
  }
  var snapStop = settings.snapStop || SNAPSTOP_DEFAULT;
  function checkScrollSpeed(value, axis) {
    var clear = function() {
      lastScrollValue[axis] = null;
    };
    var newValue = value;
    var delta;
    if (lastScrollValue[axis] !== null) {
      delta = newValue - lastScrollValue[axis];
    } else {
      delta = 0;
    }
    lastScrollValue[axis] = newValue;
    scrollSpeedTimer && clearTimeout(scrollSpeedTimer);
    scrollSpeedTimer = window.setTimeout(clear, 100);
    return delta;
  }
  function bindElement(element2) {
    target = element2;
    listenerElement = element2 === document.documentElement ? window : element2;
    listenerElement.addEventListener("scroll", startAnimation, false);
    snapLengthUnit = parseSnapCoordinatesValue(snapDestinationX, snapDestinationY);
  }
  function unbindElement() {
    listenerElement.removeEventListener("scroll", startAnimation, false);
  }
  function startAnimation() {
    speedDeltaX = checkScrollSpeed(target.scrollLeft, "x");
    speedDeltaY = checkScrollSpeed(target.scrollTop, "y");
    if (animating || speedDeltaX === 0 && speedDeltaY === 0) {
      return;
    }
    handler(target);
  }
  function handler(target2) {
    if (animationFrame) {
      clearTimeout(animationFrame);
    }
    if (scrollHandlerTimer) {
      clearTimeout(scrollHandlerTimer);
    } else {
      scrollStart = {
        y: target2.scrollTop,
        x: target2.scrollLeft
      };
    }
    scrollHandlerTimer = window.setTimeout(animationHandler, timeout);
  }
  function animationHandler() {
    if (scrollStart.y === target.scrollTop && scrollStart.x === target.scrollLeft) {
      return;
    }
    var direction = {
      y: Math.sign(speedDeltaY),
      x: Math.sign(speedDeltaX)
    };
    var snapPoint = getNextSnapPoint(target, direction);
    listenerElement.removeEventListener("scroll", startAnimation, false);
    animating = true;
    smoothScroll(target, snapPoint, function() {
      animating = false;
      listenerElement.addEventListener("scroll", startAnimation, false);
      onAnimationEnd();
      scrollStart = {
        y: target.scrollTop,
        x: target.scrollLeft
      };
    });
  }
  function getNextSnapPoint(target2, direction) {
    var snapLength = {
      y: Math.round(getYSnapLength(target2, snapLengthUnit.y)),
      x: Math.round(getXSnapLength(target2, snapLengthUnit.x))
    };
    var top = target2.scrollTop;
    var left = target2.scrollLeft;
    var startPoint = {
      y: scrollStart.y / snapLength.y || 0,
      x: scrollStart.x / snapLength.x || 0
    };
    var currentPoint = {
      y: top / snapLength.y || 0,
      x: left / snapLength.x || 0
    };
    var nextPoint = {
      y: 0,
      x: 0
    };
    if (isAboveThreshold(direction.y, currentPoint.y)) {
      if (snapStop) {
        nextPoint.y = roundByDirection(-direction.y, startPoint.y + direction.y);
      } else {
        nextPoint.y = roundByDirection(direction.y, currentPoint.y);
      }
    } else {
      nextPoint.y = roundByDirection(direction.y * -1, currentPoint.y);
    }
    if (isAboveThreshold(direction.x, currentPoint.x)) {
      if (snapStop) {
        nextPoint.x = roundByDirection(-direction.x, startPoint.x + direction.x);
      } else {
        nextPoint.x = roundByDirection(direction.x, currentPoint.x);
      }
    } else {
      nextPoint.x = roundByDirection(direction.x * -1, currentPoint.x);
    }
    var scrollTo = {
      y: nextPoint.y * snapLength.y,
      x: nextPoint.x * snapLength.x
    };
    scrollTo.y = stayInBounds(0, target2.scrollHeight, scrollTo.y);
    scrollTo.x = stayInBounds(0, target2.scrollWidth, scrollTo.x);
    return scrollTo;
  }
  function isAboveThreshold(direction, value) {
    return direction > 0 ? value % 1 > threshold : 1 - value % 1 > threshold;
  }
  function roundByDirection(direction, value) {
    if (direction === -1) {
      return Math.floor(value);
    }
    return Math.ceil(value);
  }
  function stayInBounds(min, max, destined) {
    return Math.max(Math.min(destined, max), min);
  }
  function parseSnapCoordinatesValue(x, y) {
    var regex = /([+-]?(?=\.\d|\d)(?:\d+)?(?:\.?\d*)(?:[eE][+-]?\d+)?)(px|%|vw|vh)/;
    var parsed = {
      y: {
        value: 0,
        unit: "px"
      },
      x: {
        value: 0,
        unit: "px"
      }
    };
    if (typeof y === "number") {
      parsed.y.value = y;
    } else {
      var resultY = regex.exec(y);
      if (resultY !== null) {
        parsed.y = {
          value: Number(resultY[1]),
          unit: resultY[2]
        };
      }
    }
    if (typeof x === "number") {
      parsed.x.value = x;
    } else {
      var resultX = regex.exec(x);
      if (resultX !== null) {
        parsed.x = {
          value: Number(resultX[1]),
          unit: resultX[2]
        };
      }
    }
    return parsed;
  }
  function getYSnapLength(obj, declaration) {
    if (declaration.unit === "vh") {
      return Math.max(document.documentElement.clientHeight, window.innerHeight || 1) / 100 * declaration.value;
    } else if (declaration.unit === "%") {
      return obj.clientHeight / 100 * declaration.value;
    } else {
      return declaration.value;
    }
  }
  function getXSnapLength(obj, declaration) {
    if (declaration.unit === "vw") {
      return Math.max(document.documentElement.clientWidth, window.innerWidth || 1) / 100 * declaration.value;
    } else if (declaration.unit === "%") {
      return obj.clientWidth / 100 * declaration.value;
    } else {
      return declaration.value;
    }
  }
  function isEdge(Coordinates) {
    return Coordinates.x === 0 && speedDeltaY === 0 || Coordinates.y === 0 && speedDeltaX === 0;
  }
  function smoothScroll(obj, end, callback2) {
    var position = function(start2, end2, elapsed, period2) {
      if (elapsed > period2) {
        return end2;
      }
      return start2 + (end2 - start2) * easing(elapsed / period2);
    };
    var start = {
      y: obj.scrollTop,
      x: obj.scrollLeft
    };
    var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function(fn) {
      return window.setTimeout(fn, 15);
    };
    var period = isEdge(start) ? 1 : duration;
    var startTime;
    function step(timestamp) {
      if (!startTime) {
        startTime = timestamp;
      }
      var elapsed = timestamp - startTime;
      if (!isNaN(end.y)) {
        obj.scrollTop = position(start.y, end.y, elapsed, period);
      }
      if (!isNaN(end.x)) {
        obj.scrollLeft = position(start.x, end.x, elapsed, period);
      }
      if (elapsed < period) {
        requestAnimationFrame(step);
      } else {
        if (typeof callback2 === "function") {
          return callback2(end);
        }
      }
    }
    animationFrame = requestAnimationFrame(step);
  }
  function bind() {
    bindElement(element);
  }
  function unbind() {
    unbindElement();
  }
  bind();
  return {
    bind,
    unbind
  };
}
export {
  createScrollSnap as default
};
//# sourceMappingURL=scroll-snap.js.map
